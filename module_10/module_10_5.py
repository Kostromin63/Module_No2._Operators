# Домашнее задание по теме "Многопроцессное программирование"
#
# Цель: понять разницу между линейным и многопроцессным подходом, выполнив операции обоими способами.
#
# Задача "Многопроцессное считывание":
# Необходимо считать информацию из нескольких файлов одновременно, используя многопроцессный подход.
# Подготовка:
# Скачайте архив с файлами для считывания данных и распакуйте его в проект для дальнейшего использования.
# Выполнение:
# Создайте функцию read_info(name), где name - название файла.
import multiprocessing
import datetime


def read_info(name):
    """
    Функция должна:
    Создавать локальный список all_data.
    Открывать файл name для чтения.
    Считывать информацию построчно (readline), пока считанная строка не окажется пустой.
    Во время считывания добавлять каждую строку в список all_data.
    :param name:
    :return:
    """

    with open(name, 'r') as file:
        all_data = [line for line in file]
#        return all_data

# Этих операций достаточно, чтобы рассмотреть преимущество многопроцессного выполнения программы над линейным.
# Создайте список названий файлов в соответствии с названиями файлов архива.
# Вызовите функцию read_info для каждого файла по очереди (линейно) и измерьте время выполнения и
# выведите его в консоль.
# Вызовите функцию read_info для каждого файла, используя многопроцессный подход: контекстный менеджер with и
# объект Pool. Для вызова функции используйте метод map, передав в него функцию read_info и список названий файлов.
# Измерьте время выполнения и выведите его в консоль.
# Для избежания некорректного вывода запускайте линейный вызов и многопроцессный по отдельности, предварительно
# закомментировав другой.
#
# Пример результата выполнения программы:
# Выполняемый код:
# def read_info(name):
# ...


filenames = [f'./file {number}.txt' for number in range(1, 5)]

# # Линейный вызов
# start = datetime.datetime.now()
# for name in filenames:
#     read_info(name)
# end = datetime.datetime.now()
# print(end - start)  #  0:00:05.548088
# Многопроцессный

if __name__ == "__main__":

    with multiprocessing.Pool(processes=2) as pool:
        start = datetime.datetime.now()
        pool.map(read_info, filenames)
    end = datetime.datetime.now()
    print(end - start)

    """
    if processes=2 0:00:04.052019, 0:00:04.026347, 0:00:04.032398 
    if processes=4 0:00:02.483969, 0:00:02.388527, 0:00:02.370478
    if processes=6 0:00:02.480412, 0:00:02.479891, 0:00:02.330254
    if processes=8 0:00:02.476719, 0:00:02.399123, 0:00:02.570134
    после многократных запусков # if processes=2 0:00:03.755170
    Видимо операционная система более эффективно оптимизирует часто повторяющиеся процессы?...
    """

# Вывод на консоль, 2 запуска (результаты могут отличаться):
# 0:00:03.046163 (линейный)
# 0:00:01.092300 (многопроцессный)
#
# Примечания:
# Используйте конструкцию if __name__ == '__main__' при многопроссном подходе.
# Выводить или возвращать список all_data в функции не нужно. Можете сделать это, но кол-во информации
# в файлах достигает - 10^9 строк.
# Файл module_10_5.py загрузите на ваш GitHub репозиторий. В решении пришлите ссылку на него.
