# Выполнение домашней работы по уроку "Цикл for. Элементы списка. Полезные функции в цикле"
# Цель: закрепить навык решения задач при помощи цикла for, применив знания об основных типах данных.
#
# Задача "Всё не так уж просто":
# Дан список чисел  numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
# Испольуя этот список составьте второй список primes содержащий только простые числа.
# А так же третий список not_primes, содержащий все не простые числа.
# Выведите списки primes и not_primes на экран(в консоль).
#
# Пункты задачи:
# Создадим пустые списки primes и not_primes
#
primes = []
not_primes = []
#
# При помощи цикла for переберем список numbers.
#
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
for number in numbers:
    #
    # Числа 0 и 1 не соответсвуют критериям нашего поиска, по сему будем их отрицаетльные числа категорически
    # игнорировать. Если после уточнения у заказчика отричцательные числа все таки надо будет обрабатывать,
    # тогда все проверки будем проводить с модулями чисел
    #
    if number < 2:
        continue
    elif number == 2:
        # Это без вопросов не составное число
        primes.append(number)
    else:
        # Напишем ещё один цикл for (вложенный), где будем подбирать делители для числа из 1ого цикла.
        # Отметить простоту числа можно переменной is_prime, записав в неё занчение True перед проверкой.
        # В процессе проверки на простоту записывайте числа из списка numbers в списки primes и not_primes в зависимости
        # от значения перменной is_prime после проверки (True - в prime, False - в not_prime).
        # Но так как если нам попадется составное число, то мы об этом узнаем раньше окончания цикла и можем его
        # прервать, то я решил изменить алгоритм, что бы не сравнивать делитель с делимым.
        # Будем делить число на делитель, который установим в значение сразу 2 и будем увеличивать его в
        # каждой итерации на 1, пока не получим результат без остатка, это и будет признаком комплексного числа, на
        # котором мы выйдем из цикла. Деление числа на число не имеет смысла, т.к. если мы дошли до этой операции -
        # значит чило не комплексное.
        #
        not_prime = False
        divider = 2
        for divider in range(divider, number):
            not_prime = number % divider == 0
            divider = divider + 1
            if not_prime :
                not_primes.append(number)
                break
            elif divider/number == 1:
                primes.append(number)
#
# Выведим списки primes и not_primes на экран(в консоль).
#
print('Primes: ', primes)
print('Not primes: ', not_primes)
#
# Пример результата выполнения программы:
# Исходный код:
#  numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
# Вывод на консоль:
# Primes: [2, 3, 5, 7, 11, 13]
# Not Primes: [4, 6, 8, 9, 10, 12, 14, 15]
# Примечания:
# Учтите, что число 1 не является ни простым, ни составным числом, поэтому оно отсутствует в конечных списках.
# Для проверки на простоту числа вам нужно убедиться, что выбранное число не делиться ни на что в диапазоне от 2
# до этого числа(не включительно).
# Попробуйте оптимизировать(ускорить) процесс выяснения простоты числа при помощи оператора break, когда найдёте
# делитель. (Не обязательно)
# Переменные меняющее своё булевое состояние на противоположное в процессе проверки, как is_prime, в кругах
# разработчиков называются перменными-флагами(flag).
# Ура!!! заработало!!!
